'''
The facebook message counter visualizes your privat chats on a time scale and creates clean HTML chat files.
See readme for details.

Written by Marvin Nicolas Pohl, Berkeley 2019
marvin.nicolas@me.com
'''

import os
import codecs
import pandas as pd
import numpy as np
from datetime import datetime
import matplotlib.pyplot as plt
import sys


# please put the python file in the folder directory'/facebook/messages'
path = '/Users/Marvin/Documents/Diverse/facebook-100000033726811/messages/'
safefig = True
create_chats = True


# convert the 'messages.html' file into a clean list of the directories where your chats are stored
class handle_html:
    # open the html file
    def open(self):
        html = codecs.open(self, 'r').read()

        return html

    def to_list(self):
        # split string to list of strings
        lst = self.split('href="messages/')

        # select only list entries that contain chat messages
        split_lst = [x for x in lst if 'message.html' in x]

        # cut out unnessaary characters from list elements
        chatlist = list()
        for elem in split_lst:
            split_position = elem.find('"')
            cut = elem[:split_position]
            chatlist.append(cut)

        # clear out 'non-privat' chats, i.e. chats that involve the string 'facebook'
        chatlist = [x for x in chatlist if 'facebook' not in x]

        return chatlist


def to_dataframe(chat):
    html_chat = handle_html.open(path+chat)

    split1 = html_chat.split('</div></div>')
    split1.reverse()

    index1, index2 = split1[2].find('">Generated by '), split1[2].find(' on')
    user_name = split1[2][index1+15:index2]

    split2 = [x for x in split1 if '</div' in x]

    index3 = split2[-1].rfind('">')
    partner_name = split2[-1][index3+2:]

    if ',' in partner_name:
        return pd.DataFrame(), partner_name

    else:
        name = list()
        text = list()
        date = list()
        for elem in split2:
            if user_name in elem:
                nam = user_name
                name.append(nam)
                index = elem.rfind('<div>')
                tex = elem[index+5:]
                text.append(tex)

            elif partner_name in elem:
                nam = partner_name
                name.append(nam)
                index = elem.rfind('<div>')
                tex = elem[index+5:]
                text.append(tex)

            elif '</div><div class=' in elem:
                index = elem.rfind('">')
                dat = elem[index+2:]
                date.append(dat)

        df = pd.DataFrame(list(zip(date, name, text)))
        df = df.rename(columns={0: 'date', 1: 'name', 2: 'text'})

        return df, partner_name


def to_datetime(dataframe, partner, create_chats):

    # convert list of month names into list of numbers
    # list of month names and month numbers
    month, number = (['Januar', 'Februar', 'MÃ¤rz', 'April', 'Mai', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'],
                    ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'])

    # map month names and numbers into a list of touples
    touple = list(enumerate(month, start=1))

    # replace month names by numbers
    for num, mon in touple:
        dataframe['date'] = dataframe['date'].str.replace(mon, str(num))

    # remove trailing dots from the day numbers
    dataframe['date'] = dataframe['date'].str.replace('.', '')

    # convert strings into timestamps
    for index in range(len(dataframe['date'])):
        dataframe['date'][index] = datetime.strptime(dataframe['date'][index], '%d %m %Y %H:%M')

    # create new directory '/chats'
    # only if create_chats == True in header
    if create_chats == True:
        try:
            os.mkdir('chats/')
        except OSError:
            None
        # create easy readable html file of chat
        dataframe.to_html('chats/'+partner+'.html')

    # get rid of hours and minutes
    dataframe['date'] = dataframe['date'].dt.date

    return dataframe


def count_messages(df, partner):

    # crate new column ('partner) in original dataframe cointaining ones in each row
    df[partner] = pd.Series(np.ones(len(df)))

    # group by 'date' and count 'counts'
    # reset index
    date_vs_counts = pd.DataFrame(df.groupby('date')[partner].count())
    date_vs_counts.reset_index(level=0, inplace=True)

    return date_vs_counts


# plot the results
def plot(df, partner_list, total_msg_count_list, safefig=safefig):
    legend = list(zip(partner_list,total_msg_count_list))

    df.reset_index().plot(x='date', y=partner_list, style='o', figsize=(12,len(partner_list)/5), grid=True, label=legend)

    plt.subplots_adjust(right=0.75)

    plt.legend(loc='center left', bbox_to_anchor=(1, 0.5))
    plt.ylabel('sent messages')

    # export plot as .png
    if safefig == True:
        plt.savefig('dialog_counts.png', bbox_inches="tight")
    else: None

    return plt.show()


def main():
    html_str_chats = handle_html.open(path+'messages.html')
    chatlist = handle_html.to_list(html_str_chats)

    df_list = list()
    partner_list = list()
    total_msg_count_list = list()
    counts_df_all = list()

    for i, chat in enumerate(chatlist):
        sys.stdout.write( '\r%d/' % i + str(len(chatlist)) + ' chats analyzed' )
        sys.stdout.flush()

        df, partner = to_dataframe(chat)
        partner_list.append(partner)
        total_msg_count_list.append(len(df))

        try:
            df = to_datetime(df, partner, create_chats)
        except:
            df = pd.DataFrame()
        df_list.append(df)

        try:
            cm = count_messages(df, partner)
        except:
            cm = None
            partner_list.remove(partner)
            total_msg_count_list.pop()

        counts_df = pd.DataFrame(cm)
        counts_df_all.append(counts_df)
        final_df = pd.concat(counts_df_all, sort='True')

    plot(final_df, partner_list, total_msg_count_list, safefig)

if __name__ == '__main__':
    main()
