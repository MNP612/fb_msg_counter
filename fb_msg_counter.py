'''
The facebook message counter visualizes your privat chats on a time scale and creates clean HTML chat files.
See readme for details.

IMPORTANT: Put this python file into the main folder you obtained from facebook. It should be names '/facebook-[some ranom number]'

Written by Marvin Nicolas Pohl, Berkeley 2019
marvin.nicolas@me.com
'''

import os
from os import path
import glob
import codecs
import pandas as pd
import numpy as np
import locale
from datetime import datetime
import matplotlib.pyplot as plt
import sys

# set the /messages subfolder as working directory
dir = os.path.dirname(os.path.realpath(__file__))+'/'
safefig = False
create_chats = False


# convert the 'messages.html' file into a clean list containing the directories of the chat files
class handle_html:
    # open the html file
    def open(self):
        html = codecs.open(self, 'r').read()

        return html

    def create_chatlist():
        # new (Oct 2019) file tree has a different structure
        # the personal chats are now in a /inbox subfolder
        if path.exists(dir+'messages/inbox') == True:
            chatlist = next(os.walk('messages/inbox'))[1]
            chatlist = [glob.glob(dir + 'messages/inbox/'+ x +'/message*.html') for x in chatlist]
            chatlist = [x[0] for x in chatlist if x != []]
        else:
            chatlist = next(os.walk('messages'))[1]
            chatlist = [glob.glob(dir + 'messages/'+ x +'/message*.html') for x in chatlist]
            chatlist = [x[0] for x in chatlist if x != []]

        return chatlist


def to_dataframe(chat):
    html_chat = handle_html.open(chat)

    split1 = html_chat.split('</div></div>')
    split1.reverse()

    index1, index2 = split1[2].find('>Generated by '), split1[2].find(' on')
    user_name = split1[2][index1+14:index2]

    split2 = [x for x in split1 if '</div' in x]

    index3 = split2[-1].rfind('">')
    partner_name = split2[-1][index3+2:]

    if '">Teilnehmer:' in html_chat:
        return pd.DataFrame(), partner_name
    elif '">Participants:' in html_chat:
        return pd.DataFrame(), partner_name
    else:
        name = list()
        text = list()
        date = list()
        for elem in split2:
            if user_name in elem:
                nam = user_name
                name.append(nam)
                index = elem.rfind('<div>')
                tex = elem[index+5:]
                text.append(tex)

            elif partner_name in elem:
                nam = partner_name
                name.append(nam)
                index = elem.rfind('<div>')
                tex = elem[index+5:]
                text.append(tex)

            elif 'lem">' in elem:
                index = elem.rfind('">')
                dat = elem[index+2:]
                date.append(dat)

        df = pd.DataFrame(list(zip(date, name, text)))
        df = df.rename(columns={0: 'date', 1: 'name', 2: 'text'})

        return df, partner_name


def to_datetime(dataframe, partner, create_chats):

    if 'PM' in dataframe['date'][0]:
        locale.setlocale(locale.LC_TIME, 'en_US')
        for index in range(len(dataframe['date'])):
            dataframe['date'][index] = datetime.strptime(dataframe['date'][index], '%b %d, %Y, %I:%M %p')

    else:
        locale.setlocale(locale.LC_TIME, 'de_DE')
        for index in range(len(dataframe['date'])):
            dataframe['date'][index] = datetime.strptime(dataframe['date'][index], '%d. %B %Y %H:%M')



    # create new directory '/chats'
    # only if create_chats == True in header
    if create_chats == True:
        try:
            os.mkdir('fb_msg_counter/')
        except OSError:
            None
        # create easy readable html file of chat
        dataframe.to_html('fb_msg_counter/'+partner+'.html')

    # get rid of hours and minutes
    dataframe['date'] = dataframe['date'].dt.date

    return dataframe


def count_messages(df, partner):

    # crate new column ('partner) in original dataframe cointaining ones in each row
    df[partner] = pd.Series(np.ones(len(df)))

    # group by 'date' and count 'counts'
    # reset index
    date_vs_counts = pd.DataFrame(df.groupby('date')[partner].count())
    date_vs_counts.reset_index(level=0, inplace=True)

    return date_vs_counts


# plot the results
def plot(df, partner_list, total_msg_count_list, safefig=safefig):
    legend = list(zip(partner_list,total_msg_count_list))

    df.reset_index().plot(x='date', y=partner_list, style='o', figsize=(12,len(partner_list)/5), grid=True, label=legend)

    plt.subplots_adjust(right=0.75)

    plt.legend(loc='center left', bbox_to_anchor=(1, 0.5))
    plt.ylabel('sent messages')

    # export plot as .png
    if safefig == True:
        plt.savefig('fb_msg_counter/00_fb_msg_counter.png', bbox_inches="tight")
    else: None

    return plt.show()


def main():
    chatlist = handle_html.create_chatlist()

    df_list = list()
    partner_list = list()
    total_msg_count_list = list()
    counts_df_all = list()

    for i, chat in enumerate(chatlist):
        sys.stdout.write( '\r%d/' % i + str(len(chatlist)) + ' chats analyzed' )
        sys.stdout.flush()

        df, partner = to_dataframe(chat)
        partner_list.append(partner)
        total_msg_count_list.append(len(df))

        try:
            df = to_datetime(df, partner, create_chats)
        except:
            df = pd.DataFrame()
        df_list.append(df)

        try:
            cm = count_messages(df, partner)
        except:
            cm = None
            partner_list.remove(partner)
            total_msg_count_list.pop()

        counts_df = pd.DataFrame(cm)
        counts_df_all.append(counts_df)
        final_df = pd.concat(counts_df_all, sort='True')

    plot(final_df, partner_list, total_msg_count_list, safefig)

if __name__ == '__main__':
    main()
