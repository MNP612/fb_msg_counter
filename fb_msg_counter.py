'''
The facebook message counter visualizes your privat chats on a time scale and creates clean HTML chat files.
See readme for details.

IMPORTANT:  Put this python file into the main folder you obtained from facebook.
            It should be names '/facebook-[some ranom number]'

Written by Marvin Nicolas Pohl, Berkeley 2019
marvin.nicolas@me.com
'''

import os
from os import path
import glob
import codecs
import pandas as pd
import numpy as np
import locale
from datetime import datetime
import matplotlib.pyplot as plt
import sys


# set the current folder as working directory
# make sure the file is located in the main folder ('/facebook-...')
dir = os.path.dirname(os.path.realpath(__file__))+'/'
safefig = True
create_chats = True


# preparation includes reading the HTML files
# and creating a chat list containing the directories where the chat files are located
class preparation:
    # open html file
    def open(self):
        html = codecs.open(self, 'r').read()

        return html

    # scan the '/messages' for all entries and create the chat list (list of directory paths)
    # conditional statement since new (Oct 2019) data has a different file structure
    # the personal chats are now in a '/inbox' subfolder
    def create_chatlist():
        if path.exists(dir+'messages/inbox') == True:
            chatlist = next(os.walk('messages/inbox'))[1]
            chatlist = [glob.glob(dir + 'messages/inbox/'+ x +'/message*.html') for x in chatlist]
            chatlist = [x[0] for x in chatlist if x != []]
        else:
            chatlist = next(os.walk('messages'))[1]
            chatlist = [glob.glob(dir + 'messages/'+ x +'/message*.html') for x in chatlist]
            chatlist = [x[0] for x in chatlist if x != []]

        return chatlist


# parse the string and convert it into a pandas dataframe containing 'date', 'name' and 'text'
# additionally, extract the user name and the name of the dialog partner
def to_dataframe(chat):
    html_chat = preparation.open(chat)

    split1 = html_chat.split('</div></div>')
    split1.reverse()

    # extract the users name
    index1, index2 = split1[2].find('>Generated by '), split1[2].find(' on')
    user_name = split1[2][index1+14:index2]

    split2 = [x for x in split1 if '</div' in x]
    split2 = [x.strip('</div><div></div><div>') for x in split2]

    # extract the chat partners name
    index3 = split2[-1].rfind('">')
    partner_name = split2[-1][index3+2:]

    if '">Teilnehmer:' in html_chat:
        return pd.DataFrame(), partner_name
    elif '">Participants:' in html_chat:
        return pd.DataFrame(), partner_name
    else:
        name = list()
        text = list()
        date = list()
        for elem in split2:
            if user_name in elem:
                nam = user_name
                name.append(nam)
                index = elem.rfind('<div>')
                tex = elem[index+5:]
                text.append(tex)

            elif partner_name in elem:
                nam = partner_name
                name.append(nam)
                index = elem.rfind('<div>')
                tex = elem[index+5:]
                text.append(tex)

            elif 'lem">' in elem:
                index = elem.rfind('">')
                dat = elem[index+2:]
                date.append(dat)

        # cast the lists 'date', name' and 'text' into one pandas dataframe
        df = pd.DataFrame(list(zip(date, name, text)))
        # lable colums
        df = df.rename(columns={0: 'date', 1: 'name', 2: 'text'})

        return df, partner_name


# the 'date' entries in the dataframe are strings
# this function converts these strings to timestamps
# this function also creates easier readable html files if statement 'create_chats' is set to 'True'
# date formats are provided in different formats from facebook
# it depends on your language settings but facebook also changed the format during the last year
# Recommended is to set you language setting to english befor requesting data from facebook
def to_datetime(dataframe, partner, create_chats):
    # the following conditional statement accounts for en_US and de_DE formats
    # english
    if 'AM' in dataframe['date'][0]:
        locale.setlocale(locale.LC_TIME, 'en_US')
        # convert strings into timestamps
        for index in range(len(dataframe['date'])):
            dataframe['date'][index] = datetime.strptime(dataframe['date'][index], '%b %d, %Y, %I:%M %p')

    elif 'PM' in dataframe['date'][0]:
        locale.setlocale(locale.LC_TIME, 'en_US')
        for index in range(len(dataframe['date'])):
            dataframe['date'][index] = datetime.strptime(dataframe['date'][index], '%b %d, %Y, %I:%M %p')

    # german
    else:
        locale.setlocale(locale.LC_TIME, 'de_DE')
        for index in range(len(dataframe['date'])):
            dataframe['date'][index] = datetime.strptime(dataframe['date'][index], '%d. %B %Y %H:%M')

    # create new directory '/fb_msg_counter'
    # only if create_chats == True in header
    if create_chats == True:
        try:
            os.mkdir('fb_msg_counter/')
        except OSError:
            None
        # create easy readable HTML file of chat
        dataframe.to_html('fb_msg_counter/'+partner+'.html')

    # get rid of trailing hours and minutes
    dataframe['date'] = dataframe['date'].dt.date

    return dataframe


# create a smaller dataframe that groups the dialog by date and counts the number of messages for each day
def count_messages(df, partner):

    # crate new column ('partner) in original dataframe cointaining ones in each row
    df[partner] = pd.Series(np.ones(len(df)))

    # group by 'date' and count 'counts'
    # reset index
    date_vs_counts = pd.DataFrame(df.groupby('date')[partner].count())
    date_vs_counts.reset_index(level=0, inplace=True)

    return date_vs_counts


# plot the results
def plot(df, partner_list, total_msg_count_list, safefig=safefig):
    # the plot legend ('lgnd') contains the partner name and the total messages ever had
    lgnd = list(zip(partner_list,total_msg_count_list))

    df.reset_index().plot(x='date', y=partner_list, style='o', figsize=(12,len(partner_list)/5), grid=True, label=lgnd)

    plt.subplots_adjust(right=0.75)

    plt.legend(loc='center left', bbox_to_anchor=(1, 0.5))
    plt.ylabel('sent messages')

    # export plot as PNG file if statement 'safefig' is set to 'True' in the header
    if safefig == True:
        plt.savefig('fb_msg_counter/00_fb_msg_counter.png', bbox_inches="tight")
    else: None

    return plt.show()


# main function creates a chat list and loops through all functions for each element in the chat list
def main():
    chatlist = preparation.create_chatlist()

    df_list = list()
    partner_list = list()
    total_msg_count_list = list()
    counts_df_all = list()

    for i, chat in enumerate(chatlist):
        # print a counter in the console
        sys.stdout.write( '\r%d/' % i + str(len(chatlist)) + ' chats analyzed' )
        sys.stdout.flush()

        df, partner = to_dataframe(chat)
        partner_list.append(partner)
        total_msg_count_list.append(len(df))

        # if execution fails the dataframe gets deleted
        # and no 'count_messages' dataframe is created and the respective element from 'partner_list' gets removed
        try:
            df = to_datetime(df, partner, create_chats)
        except:
            df = pd.DataFrame()
        df_list.append(df)

        try:
            cm = count_messages(df, partner)
        except:
            cm = None
            partner_list.remove(partner)
            total_msg_count_list.pop()

        counts_df = pd.DataFrame(cm)
        counts_df_all.append(counts_df)
        final_df = pd.concat(counts_df_all, sort='True')

    plot(final_df, partner_list, total_msg_count_list, safefig)


if __name__ == '__main__':
    main()
