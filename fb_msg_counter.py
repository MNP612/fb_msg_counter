# This script parses html s generated from facebook.com.
# It converts these into pandas dataframes in order to visualize the total number of conversation with all your contacts.
# The data can be requested from facebook via ...
# Written by Marvin Nicolas Pohl, Berkeley 2019

# import modules
import codecs
import re
import pandas as pd
from datetime import datetime
import numpy as np
import matplotlib.pyplot as plt
import os # to create the directory '/chats' for easy readable html files


# directory path of 'messages.html'
# to be found in the '/facebook/messages' folder
path = '/Users/Marvin/Documents/Diverse/facebook-100000033726811/messages/'


# define functions


# convert the 'messages.html' file into a clean list of the directories where your chats are stored
def message_file_to_chat_list(path):

    html_string = codecs.open(path+'messages.html', 'r').read()

    # split string to list of strings
    lst = html_string.split('href="messages/')

    # select only list entries that contain chat messages
    split_list = []
    for elem in lst:
        if 'message.html' in elem:
            split_list.append(elem)

    # cut out unnessaary characters from list elements
    chat_list = []
    for elem in split_list:
        cut = (re.search('(.*)">', elem).group(1))
        cut = (re.search('(.*)">', cut).group(1))
        chat_list.append(cut)

    # clear out meaningless elements
    clear_chat_list = []
    for elem in chat_list:
        if 'facebook' not in elem:
            clear_chat_list.append(elem)

    return clear_chat_list


# loop through a set of funtions that read and parse your chats which are stored in subfolders of path as html files
# functions are enumarated and defined later on
def clean_df(chat_list, create_chats=True):

    df1 = pd.DataFrame()
    partner_list = []

    for file in short_chat_list:
        # call functions
        raw_text = load_file(path+file) # Function 1
        df2, user, partner = html_string_to_dataframe(raw_text) # Function 2
        to_datetime(df2, partner, create_chats=create_chats) # Function 3
        date_vs_counts = count_messages(df2, partner) # Function 4
        date_vs_counts.set_index('date', inplace=True)

        partner_list.append(partner)
        #partner_date_list.append(partner+' (date)')


        df1 = df1.append(date_vs_counts, sort=False)

    return df1, partner_list


# Function 1
# read messages.html file and create a string
def load_file(path):
    html = codecs.open(path, 'r').read()

    return html


# Function 2
# parse the string and convert it into a pandas dataframe containing 'date', 'name' and 'text'
# additionally, extract the user name and the name of the dialog partner
# return dataframe, user_name, dialog_partner
def html_string_to_dataframe(html):

    # split string to list of strings
    split_string = html.split('</div></div>')

    # remove empty elements in 'split_string'
    lst = []
    for elem in split_string:
        if '<div' in elem:
            lst.append(elem)

    # reverse list order
    lst.reverse()

    # remove irrelevant characters from list elements that contain 'date' information
    # in the original string the 'date' is always printed after a "> string
    short_lst = []
    for elem in lst:
        cut = (re.search('">(.*)', elem).group(1))
        short_lst.append(cut)

    # extract the user name
    user_name = re.search('Generated by (.*) on', short_lst[0]).group(1)

    # drop first and last 4 elements of 'split_string' since they contain irrelevant information
    short_lst = short_lst[1:-4]

    # cut out 'names' and 'message' text out of the string list and cast them into a touple
    lst = []
    for elem in short_lst:
        if 'div class=' in elem:
            cut = (re.search('\">(.*)</div', elem).group(1), re.search('<div><div>(.*)', elem).group(1))
            lst.append(cut)
        else: lst.append(elem)

    # arrange 'date', 'name' and 'text' in a list of triplets
    triplet_lst = []
    for i in list(range(0,len(lst),2)):
        merged_elem = (lst[i], lst[i+1][0], lst[i+1][1])
        triplet_lst.append(merged_elem)

    # extract the name of the dialog partner
    for elem in np.transpose(triplet_lst)[1]:
        if elem != user_name:
            dialog_partner = elem
            break

    # load 'triplet_lst' as pandas dataframe
    dataframe = pd.DataFrame(triplet_lst)

    # lable colums
    dataframe = dataframe.rename(columns={0: 'date', 1: 'name', 2: 'text'})

    return dataframe, user_name, dialog_partner


# Function 3
# the 'date' entries in the dataframe are strings
# this function converts these strings to timestamps
# this function also creates easier readable html files if statement 'create_chats' is set to 'True'
def to_datetime(dataframe, partner, create_chats):

    # convert list of month names into list of numbers
    #list of month names
    month = ['Januar', 'Februar', 'MÃ¤rz', 'April', 'Mai', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember']

    # list of month numbers
    number = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12']

    # map month names and numbers into a list of touples
    touple = list(map(list, zip(*(month, number))))

    # replace month names by numbers
    for mon, num in touple:
        dataframe['date'] = dataframe['date'].str.replace(mon, num)

    # remove trailing dots from the day numbers
    dataframe['date'] = dataframe['date'].str.replace('.', '')

    # convert strings into timestamps
    ran = list(range(len(dataframe['date'])))
    for index in ran:
        dataframe['date'][index] = datetime.strptime(dataframe['date'][index], '%d %m %Y %H:%M')

    # create new directory '/chats'
    if create_chats == True:
        try:
            os.mkdir('chats/')
        except OSError:
            None
        # create easy readable html file of chat
        dataframe.to_html('chats/'+partner+'.html')
    #else: None


    # get rid of hours and minutes
    dataframe['date'] = dataframe['date'].dt.date

    return dataframe


# Function 4
# create a smaller dataframe that groups the dialog by date and counts the number of messages for each day
def count_messages(df, partner):

    # crate new column ('partner) in original dataframe cointaining ones in each row
    df[partner] = pd.Series(np.ones(len(df)))

    # group by 'date' and count 'counts'
    # reset in index
    date_vs_counts = pd.DataFrame(df.groupby('date')[partner].count())
    date_vs_counts.reset_index(level=0, inplace=True)

    return date_vs_counts


# plot the results
def plot(df, partner_list):
    final_df.reset_index().plot(x='date', y=partner_list, style='o', figsize=(15,5), grid=True, label=partner_list)
    plt.ylabel('sent messages')



    plt.savefig('dialog_counts.png')


    return plt.show()


# call functions


# call function to create list of directories where your chats are stored
clear_chat_list = message_file_to_chat_list(path)
# 'clear_chat_list' is still buggy -> work only with the first three chats for the moment -> work on that issue!
short_chat_list = clear_chat_list[0:3]
# call function to create a clean dataframe and a list of chat partners
final_df, partner_list = clean_df(short_chat_list)
# call plot function
plot(final_df, partner_list)

# export plot as .png
